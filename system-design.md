### Frontend System design

System design is the process of ideating and designing a scalable system adhering to a problem statement.
System design consists of two parts -> HLD and LLD

#### HLD
HLD or high-level design involves defining:
- Requirements: functional and non-functional
- Scoping and prioritizing the functional and non-functional requirements that will be touch-based.
- Tech choices to accomplish the design successfully

#### LLD
LLD or low-level design involves:
- Component architecture
- Protocols, schemas, and implementation details


### HLD
- Requirements: Functional
  - Essentially building blocks of the application
  - Mandatory features that shape the product

- Requirements: Non-functional
  - Generic features that enhance the UX, although it is termed as non-functional, it is important to implement the non-functional requirements as well.
  - Accessibility
  - Availability
  - Asset Optimization
  - Web Vitals
  - Consistency
  - Localisation
  - Performance
  - Logging & Monitoring
  - Security
 

#### Performance (Network optimization)
- Lazy loading
- Using `async` & `defer` in script tags to avoid render blocking
- Intersection Observer (content-visibility)
- Resource hinting (dns-prefetch, preconnect(dns-prefetch+TCP handshake), prefetch(low priority connection initiation for resources that might be used in the future), prerender)
- Rendering (Parsing -> Creating DOM & CSSOM -> Create render tree -> Create layout tree -> Create paint tree -> Paint -> Compositing(to render items in correct layer order)

#### Performance (Asset optimization)
- Using `picture`'s `srcset`
- Use infinite scrolling on content visibility



## Security
### JWT
- Earlier, upon authentication, a session ID would be generated for an authenticated user, stored on the server, and sent to the user as a cookie. On corresponding requests for authorization, the server looks up a user with the session ID and then responds, essentially storing the session ID on the server.
- A JSWT on the other hand is a token generated by the server on successful authentication, generates a token based on a private key, and sends this token to the client without storing it on the server. Upon corresponding requests, the server verifies the token signature and responds accordingly. A JWT token consists of 3 parts separated by `.` the first part encodes the algorithm used for encryption, the second part represents the payload, and the third part is the signature part created by clubbing the encoded header and payload string and encrypted using a private key.

### XSS (Cross-site scripting)

XSS or cross-site scripting is a compromised security attack that lets the hacker run a malicious script on the target's browser. It could be done in 2 ways.
- Stored XSS attack: This happens when there is a lack of input sanitization. This would allow the attacker to input a malicious script in an input field. This value is stored or persisted on the server/database and subsequently, whenever other users try to access this part of the application, the script is executed on the client side and they become a victim of the attack.
- Reflected XSS attack: This involves identifying various entry points of the application that are vulnerable to this attack, mostly trying to run the script on different paths and query parameters. E.g.: `https://xyz.com/path1?key=</script><script>alrt(1)</script>`, if visiting this link renders an alert, it means that the security of the application is compromised here. The attacker can then send this link to the target and if the target clicks it, the attacker will be able to run this script on the target's browser and retrieve the desired information, i.e, using `document.cookie` can be used to sniff session cookie which would enable the attacker to gain login access of the target user without the need of login credentials. 

### CSRF (Cross-site Request Forgery)

As the name suggests, it is the ability to make a request from another origin by exploiting the session ID/cookie to disguise it as the actual user making the request.
This attack works even with `CORS` enabled. This can be accomplished by using `form` action, when a form is submitted using the `action` attribute, the rules of `CORS` are not applied.
In order to protect the users against this attack, a CSRF token should be issued by the server along with the auth token or session id, this CSRF token is stored in-memory of the server. So everytime a request is made, along with the auth token, the csrf token is verified for its credibility. Since the cross-site wouldn't have access to this, the attack would fail. 
